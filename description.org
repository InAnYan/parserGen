* Цель
  Из файла, в котором написана грамматика языка, создать на С++ текст парсера.

* Основной язык написания
** Объявление (простое)
   _$метод$ ::= $метод$  $( | )$ $<токен>$ $+$ $*$ $? $[]$ . и т.д. в различных сочитаниях._
   Это обычная строка, как в BNF, начинается с имени определения, которое служит именем
   метода в парсере и именем узла ДАС и называется "метод".
   После символа "присваивания" идёт описание грамматики, похожее на BNF.
   В конце обязательно ставится точка.
*** Примеры (грамматика Паскаля):
	* Program ::= <PROGRAM> <IDENTIFIER> <SEMICOLON> Block <DOT> .
	  - Создаёт метод с парсере ("parseProgram") и ноду ("ProgramNode"). Требует определённые 
		токены и для Block вызывается соответствующий метод парсера ("parseBlock").
	* Block ::= Declaration+ Compound .
	  - Блок состоит из множества (или нуля) определений и блока из "begin" "end".
	* Declaration ::= (VarDecl | ProcDecl) .
	  Определение состоит либо из определения переменной, либо из определения процедуры.
** Методы
   Это слова из букв разного регистра, по типу: "Program", "Variable". 
   Они пишутся в самом начале объявления и могут ипсользоваться в других объявлениях.
   Служат для имени метода парсера и узла ДАС.
   Если они написаны внутри определения грамматики, то это равноценно вызову метода.
** Токены
   Если нужно конкретное требование по определённой операции, ключевому слову или 
   идентификатору, то токены записуются в "стрелочных?" кавычках.
** Специальные символы
   Их несколько:
   - Вертикальная черта - обозначает выбор вариантов. Каждая запись таких выборов обязательно
	 должна содержаться в круглых скобках. Каждый из вариантов ограничевается вертикальной
	 чертой
   - Квадратные скобки - обозначает необязательную часть грамматики ("ноль либо один").
	 Поддерживается только опциональные методы. [elseBlock]
   - Плюс - "один или несколько"
   - Asterisk - "ноль, один или несколько"
** Объявление (сложное)
   В процесе написания этой программы я столкунлся с той проблемой, что узлы ДАС требуют
   пременных для создания. Например: узел программы требует имени программы и узла блока,
   узел переменной требует идентификатор, и т.п.
   Поэтому я решил усложнить определение:
   $метод$($аргументы$) ::= $токен$:имяАргумента1 $метод$:имяАргумента2 . и т.п.
   В начале объявления можно в круглых скобках указать аргументы, которая принимает оределенная
   нода ДАС. Чтобы задать те члены граматики, которые должна иметь нода, после них нужно написать
   двоеточие и имя аргумента.
*** Пример:
	Program(name, block) ::= <PROGRAM> <IDENTIFIER>:name <SEMICOLON> Block:block <DOT> .

* Синтез исходного кода
** Во что превращается определение
   В консоль выводится исходный код определения. Он возвращает уникальный указатель на узел ДАС,
   не принимает аргументов, имя метода C++ состоит из имени определения.
** Метод
   Если это не название определения, то в коде будет вызваться соответствующий метод парсинга.
   Если указано, что он принадлежит какому либо полю узла ДАС, то будет создана перемнная 
   уникального указателя, которая в конце определения в "return" при создании ноды будет передана
   как аргумент с использованием "std::move()". 
** Токен
   Будет вызван соответствующий метод парсера "require". Если указано, что он принадлежит переменной,
   то он будет также создан и сохранён, как и метод.
** Вариант
   Вариант анализирует первые токены его вариантов и создаёт конструкцию "if, else if, else".
   Вызывается метод парсера "currentToken()" (который не съедает токен как "match" или "require") и 
   тип токена сверяется с требуемым.
** Квадратные скобки
   Всегда создают переменную типа метода со стандартным значением "nullptr". Потом создаёт блок "if",
   условием которого является: не равен ли тип текущего токена требуемому типу опционального метода?
** Плюс
   Создаётся вектор типа метода. Создаётся блок while(currentToken().type ... ", условие кторого является:
   не равен ли тип текущего токена требуемому типу метода?
** Asterisk
   Точно так же как и "плюс", только конструкция "while" помещается в конструкцию "if" с тем же условием.

* Проблемы
** Вариант
   Сейчас вариант проверяет первые токены его вариантов. Но что если разные определения начинаются с одного
   и того же токена?
** Ноль
   Что делать если какая-либо нода может быть пустой? Допустим есть NullNode, но что если потребуется
   NullStatementNode?
   "nullptr" не вариант, так как паттерн Посетитель не будет работать.

* Что сделать
** Инлайн
** Оптимизация первого бесплоезного токена
** Оптимизация опционального не по первому токену, а по токену, что после опционального
** Выражения
** Аргументы